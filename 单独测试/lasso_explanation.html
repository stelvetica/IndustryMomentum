<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lasso 因子计算逻辑详解</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        .container {
            background-color: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        }
        h1 { color: #2c3e50; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        h2 { color: #3498db; margin-top: 30px; }
        h3 { color: #16a085; }
        
        .step-box {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            background-color: #fff;
            transition: transform 0.2s;
        }
        .step-box:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            border-color: #3498db;
        }
        
        .matrix-viz {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        .matrix {
            border: 2px solid #333;
            border-radius: 5px;
            padding: 10px;
            background: #f0f8ff;
            position: relative;
        }
        .matrix::before { content: attr(data-label); position: absolute; top: -25px; left: 0; width: 100%; text-align: center; font-weight: bold; color: #555; }
        
        .vector {
            border: 2px solid #333;
            border-radius: 5px;
            padding: 10px;
            background: #fff0f5;
            position: relative;
        }
        .vector::before { content: attr(data-label); position: absolute; top: -25px; left: 0; width: 100%; text-align: center; font-weight: bold; color: #555; }

        .arrow { font-size: 24px; margin: 0 15px; color: #7f8c8d; }
        
        .highlight { color: #e74c3c; font-weight: bold; }
        .code-snippet {
            background-color: #f4f4f4;
            padding: 15px;
            border-left: 4px solid #3498db;
            font-family: Consolas, monospace;
            overflow-x: auto;
        }
        
        .coef-viz {
            display: flex;
            height: 150px;
            align-items: flex-end;
            gap: 5px;
            margin: 20px 0;
            border-bottom: 2px solid #333;
            padding-bottom: 5px;
        }
        .bar {
            width: 30px;
            background-color: #bdc3c7;
            text-align: center;
            position: relative;
            transition: height 0.5s;
        }
        .bar.active { background-color: #e74c3c; }
        .bar-label {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%) rotate(-45deg);
            font-size: 10px;
            white-space: nowrap;
        }
        .bar-val {
            position: absolute;
            top: -20px;
            width: 100%;
            font-size: 10px;
        }
        
        .note {
            background-color: #fff8e1;
            border-left: 4px solid #ffc107;
            padding: 10px 15px;
            font-size: 0.9em;
            margin-top: 10px;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Lasso 因子计算逻辑图解</h1>
    <p>本文档旨在直观解释 <strong>行业间动量 (Cross-Industry Momentum) Lasso 因子</strong> 的计算过程。</p>

    <div class="step-box">
        <h2>核心思想</h2>
        <p>我们想知道：<strong>哪些行业的过去表现，能预测目标行业（比如“电池”）的未来表现？</strong></p>
        <p>如果用普通回归，30个行业互相预测，变量太多、噪音太大。<strong>Lasso 回归</strong> 的作用就是像筛子一样，滤掉无关的噪音行业，只保留几个真正的“领头羊”。</p>
    </div>

    <div class="step-box">
        <h2>步骤 1: 构建训练数据 (Rolling Window)</h2>
        <p>假设当前时间是 <strong>2023年12月末</strong>。我们要训练一个模型来预测 <strong>电池行业</strong>。</p>
        <p>我们取过去 <strong>12个月</strong> (train_periods=12) 的数据：</p>

        <div class="matrix-viz">
            <div class="matrix" data-label="X: 特征矩阵 (12×30)">
                <div>2022-12 所有行业收益</div>
                <div>2023-01 所有行业收益</div>
                <div>...</div>
                <div>2023-11 所有行业收益</div>
            </div>
            <div class="arrow">→ 预测 →</div>
            <div class="vector" data-label="y: 目标向量 (12×1)">
                <div>2023-01 电池行业收益</div>
                <div>2023-02 电池行业收益</div>
                <div>...</div>
                <div>2023-12 电池行业收益</div>
            </div>
        </div>
        
        <div class="note">
            <strong>注意错位：</strong> 用 $t$ 月的特征 $X_t$，预测 $t+1$ 月的目标 $y_{t+1}$。这是为了捕捉<strong>领先滞后关系</strong>。
        </div>
    </div>

    <div class="step-box">
        <h2>步骤 2: Lasso 模型训练 (特征筛选)</h2>
        <p>这是最关键的一步。我们求解以下优化问题：</p>
        <p>$$ \min_{\beta} \left( \sum_{t=1}^{12} (y_t - \sum_{j=1}^{30} X_{t,j}\beta_j)^2 + \lambda \sum_{j=1}^{30} |\beta_j| \right) $$</p>
        
        <ul>
            <li>第一项：预测误差要小（拟合得准）。</li>
            <li>第二项 (<strong>L1 正则化</strong>)：系数绝对值之和要小（模型要简单）。</li>
            <li>$\lambda$ (Alpha)：惩罚力度。代码使用 <code>LassoLarsIC(criterion='aic')</code> 自动选择最优的 $\lambda$。</li>
        </ul>

        <h3>筛选结果示意：</h3>
        <p>Lasso 会将大多数无关行业的系数 $\beta$ 强行压缩为 <strong>0</strong>。</p>

        <div class="coef-viz">
            <div class="bar" style="height: 10px;"><span class="bar-label">煤炭</span></div>
            <div class="bar active" style="height: 80px;"><span class="bar-val">0.6</span><span class="bar-label">有色</span></div>
            <div class="bar" style="height: 5px;"><span class="bar-label">钢铁</span></div>
            <div class="bar" style="height: 0px;"><span class="bar-label">化工</span></div>
            <div class="bar active" style="height: 40px; background-color: #2ecc71;"><span class="bar-val">0.3</span><span class="bar-label">汽车</span></div>
            <div class="bar" style="height: 5px;"><span class="bar-label">...</span></div>
            <div class="bar" style="height: 5px;"><span class="bar-label">银行</span></div>
        </div>
        <p><strong>结果解读：</strong> 模型告诉我们，预测“电池”行业，只需要看“有色金属”（上游成本）和“汽车”（下游需求）。其他行业都是噪音，被剔除了。</p>
    </div>

    <div class="step-box">
        <h2>步骤 3: 因子值预测 (Out-of-Sample)</h2>
        <p>现在我们有了训练好的模型（系数 $\beta$）。</p>
        <p>今天是 <strong>2023年12月末</strong>，我们想知道下个月（2024年1月）电池行业会怎么样。</p>

        <div class="matrix-viz">
            <div class="vector" data-label="X_new: 12月末最新收益">
                <div>煤炭: -2%</div>
                <div class="highlight">有色: +5%</div>
                <div>钢铁: +1%</div>
                <div>...</div>
                <div class="highlight">汽车: +2%</div>
            </div>
            <div class="arrow">×</div>
            <div class="vector" data-label="β: 稀疏系数">
                <div>0</div>
                <div class="highlight">0.6</div>
                <div>0</div>
                <div>...</div>
                <div class="highlight">0.3</div>
            </div>
            <div class="arrow">=</div>
            <div class="vector" style="background: #e8f8f5;" data-label="Factor: 因子值">
                <div style="font-size: 1.2em; font-weight: bold; color: #16a085;">3.6%</div>
            </div>
        </div>

        <p>计算过程：$ 0.6 \times 5\% + 0.3 \times 2\% = 3.6\% $</p>
        <p>这个 <strong>3.6%</strong> 就是电池行业在 2023年12月末的 <strong>Lasso 因子值</strong>。值越高，预期下个月表现越好。</p>
    </div>

    <div class="step-box">
        <h2>深入理解: Lambda ($\lambda$) 与 AIC 的关系</h2>
        <p>您可能会问：<strong>模型是怎么知道哪个 $\lambda$ 最好的？</strong> 这就是 AIC 的作用。</p>
        
        <p>AIC (赤池信息量准则) 是衡量模型“性价比”的指标：</p>
        <div style="background: #e8f6f3; padding: 10px; border-radius: 5px; text-align: center; margin: 10px 0;">
            $$ \text{AIC} = \underbrace{n \ln(\text{RSS})}_{\text{拟合误差}} + \underbrace{2k}_{\text{复杂度惩罚}} $$
        </div>
        <ul>
            <li><strong>RSS (残差平方和)</strong>: 模型预测得准不准。$\lambda$ 越小，拟合越好，RSS 越小。</li>
            <li><strong>k (非零系数个数)</strong>: 模型用了多少个变量。$\lambda$ 越大，系数被压为0的越多，k 越小。</li>
        </ul>

        <h3>AIC 曲线示意图</h3>
        <p>随着 $\lambda$ 的变化，AIC 呈现出一个 <strong>U型曲线</strong>：</p>

        <div style="position: relative; height: 250px; border-left: 2px solid #333; border-bottom: 2px solid #333; margin: 20px;">
            <!-- Y轴标签 -->
            <div style="position: absolute; top: -20px; left: -10px;">AIC 值</div>
            <div style="position: absolute; top: 10px; left: 10px; color: #e74c3c;">过拟合区</div>
            <div style="position: absolute; top: 10px; right: 10px; color: #e67e22;">欠拟合区</div>

            <!-- X轴标签 -->
            <div style="position: absolute; bottom: -30px; right: 0;">Lambda ($\lambda$) 正则化强度 &rarr;</div>
            <div style="position: absolute; bottom: -20px; left: 0;">0 (复杂模型)</div>
            <div style="position: absolute; bottom: -20px; right: 0;">大 (稀疏模型)</div>

            <!-- 曲线 (SVG) -->
            <svg width="100%" height="100%" viewBox="0 0 400 200" style="position: absolute; bottom: 0; left: 0;">
                <!-- U型曲线 -->
                <path d="M 10 50 Q 100 180 200 150 T 390 10" fill="none" stroke="#3498db" stroke-width="3" />
                
                <!-- 最低点标记 -->
                <circle cx="200" cy="150" r="6" fill="#2ecc71" />
                <line x1="200" y1="150" x2="200" y2="200" stroke="#2ecc71" stroke-width="2" stroke-dasharray="5,5" />
                <text x="180" y="130" fill="#2ecc71" font-weight="bold">最佳点</text>
            </svg>
        </div>

        <p><strong>自动选择过程：</strong></p>
        <ol>
            <li><strong>左侧 ($\lambda$ 太小)</strong>: 虽然误差 (RSS) 很小，但用了太多变量 ($2k$ 很大)，导致 AIC 很高（过拟合）。</li>
            <li><strong>右侧 ($\lambda$ 太大)</strong>: 虽然模型简单 ($2k$ 很小)，但误差 (RSS) 太大，导致 AIC 也很高（欠拟合）。</li>
            <li><strong>底部 (绿色点)</strong>: <code>LassoLarsIC</code> 找到了 AIC 最低的点。这个点对应的 $\lambda$ 就是最佳参数，此时模型在“预测准确”和“简洁稀疏”之间达到了完美平衡。</li>
        </ol>

        <div class="note">
            <strong>$\lambda$ 的取值范围是多少？</strong>
            <br>
            理论上 $\lambda \in [0, \infty)$。
            <ul>
                <li><strong>$\lambda = 0$</strong>: 相当于普通线性回归 (OLS)，不做任何筛选，保留所有变量。</li>
                <li><strong>$\lambda \ge \lambda_{max}$</strong>: 惩罚太强，所有系数都被压为 0（空模型）。$\lambda_{max}$ 是由数据决定的一个阈值。</li>
            </ul>
            <p>在我们的场景（股票收益率预测）中，$\lambda$ 通常是一个<strong>非常小的数</strong>（例如 0.0001 级别）。这是因为收益率本身的数值很小（通常在 -0.1 到 +0.1 之间），如果 $\lambda$ 设为 1，那对于模型来说就是“天文数字”般的惩罚，会导致所有系数瞬间归零。</p>
        </div>
        <div class="note">
            <h3>为什么 Lasso 的公式和 AIC 的公式看起来这么像？</h3>
            <p>您的观察非常敏锐！它们本质上都在做同一件事：<strong>奥卡姆剃刀原理（如无必要，勿增实体）</strong>。</p>
            <div style="display: flex; gap: 20px; margin-top: 10px;">
                <div style="flex: 1; padding: 10px; border: 1px dashed #333; border-radius: 5px; position: relative;">
                    <div style="text-align: center; font-weight: bold; margin-bottom: 5px;">Lasso 优化目标</div>
                    <div style="font-size: 0.9em; text-align: center;">$$ \bbox[#ffffcc, 5px, border: 2px solid #f1c40f]{\text{RSS (误差)}} + \lambda \times (\text{系数绝对值之和}) $$</div>
                    <p style="font-size: 0.85em; color: #666; margin-top: 5px;">用于<strong>生成模型</strong>：在训练过程中直接惩罚复杂的系数，强迫它们变小或归零。</p>
                </div>
                <div style="flex: 1; padding: 10px; border: 1px dashed #333; border-radius: 5px;">
                    <div style="text-align: center; font-weight: bold; margin-bottom: 5px;">AIC 评价准则</div>
                    <div style="font-size: 0.9em; text-align: center;">$$ n \ln(\bbox[#ffffcc, 5px, border: 2px solid #f1c40f]{\text{RSS (误差)}}) + 2 \times (\text{变量个数}) $$</div>
                    <p style="font-size: 0.85em; color: #666; margin-top: 5px;">用于<strong>挑选模型</strong>：在模型生成后，惩罚使用了太多变量的模型。</p>
                </div>
            </div>
            <p style="margin-top: 10px;">它们都是 <strong>“拟合优度” vs “模型复杂度”</strong> 的权衡。您截图中标出的那一项，正是这两个公式中共享的<strong>核心误差项 (RSS)</strong>！Lasso 努力让它变小（但受限于 $\lambda$），AIC 则忠实记录下它最终的大小。</p>
        </div>

        <div class="note" style="border-left-color: #e74c3c; background-color: #fdedec;">
            <h3>为什么 AIC 公式里没有 $\lambda$？</h3>
            <p>这是一个非常棒的问题！AIC 公式 $ \text{AIC} = n \ln(\text{RSS}) + 2k $ 里确实没有直接出现 $\lambda$。</p>
            <p><strong>原因：$\lambda$ 是幕后推手，通过影响 $k$ 和 $\text{RSS}$ 来隐式地改变 AIC。</strong></p>
            <div style="display: flex; align-items: center; justify-content: center; gap: 10px; margin: 15px 0;">
                <div style="text-align: center;">
                    <div style="font-weight: bold; color: #3498db;">$\lambda$ (控制者)</div>
                    <div style="font-size: 0.8em;">改变正则化强度</div>
                </div>
                <div class="arrow">→</div>
                <div style="text-align: center; border: 1px solid #ddd; padding: 10px; border-radius: 5px; background: white;">
                    <div><strong>模型结构改变</strong></div>
                    <div style="color: #e74c3c;">$k$ (变量个数) 变化</div>
                    <div style="color: #2ecc71;">$\text{RSS}$ (误差) 变化</div>
                </div>
                <div class="arrow">→</div>
                <div style="text-align: center;">
                    <div style="font-weight: bold; color: #9b59b6;">AIC (裁判分数)</div>
                    <div style="font-size: 0.8em;">最终得分改变</div>
                </div>
            </div>
            <p><strong>打个比方：</strong></p>
            <ul>
                <li><strong>$\lambda$ 是厨师放的“盐”</strong>。</li>
                <li><strong>AIC 是美食评委的“打分”</strong>。</li>
            </ul>
            <p>评委的打分表里只有“味道”和“卖相”，没有“盐的克数”这一项。但是，<strong>盐放多少 ($\lambda$) 直接决定了菜的味道 ($\text{RSS}$)</strong>。所以，虽然 AIC 公式里没写 $\lambda$，但 $\lambda$ 的影子无处不在。</p>
        </div>

        <div class="note" style="border-left-color: #8e44ad; background-color: #f4ecf7;">
            <h3>Lasso 为什么要“最小化”那个公式？有什么意义？</h3>
            <p>您问到了 Lasso 的灵魂！Lasso 的优化目标是：</p>
            <div style="text-align: center; margin: 10px; font-weight: bold;">
                $$ \min_{\beta} \left( \underbrace{\text{预测误差}}_{\text{我想准}} + \lambda \times \underbrace{\text{系数大小}}_{\text{我想简}} \right) $$
            </div>
            <p>这个“最小化”的过程，实际上是在做一场<strong>艰难的妥协</strong>。</p>
            <ul>
                <li><strong>如果不看惩罚项</strong>：模型会为了迎合每一个数据点，把系数弄得很复杂，导致“过拟合”。</li>
                <li><strong>如果不看误差项</strong>：模型会直接把所有系数变成 0，什么都不预测，导致“欠拟合”。</li>
            </ul>
            <p><strong>最小化的意义：</strong></p>
            <p>对于给定的 $\lambda$（比如 $\lambda=0.1$），Lasso 算法在茫茫多的系数组合中搜索，最终找到了<strong>唯一的一组系数 $\beta^*$</strong>。这组系数的特点是：<strong>它在“足够准”和“足够简”之间找到了那个总分最低的平衡点。</strong></p>
            <p>任何其他的系数组合，要么误差太大，要么太复杂，算出来的总分都会比这一组高。</p>
        </div>

        <div class="note" style="border-left-color: #27ae60; background-color: #e9f7ef;">
            <h3>所以，每一个 $\lambda$ 都对应唯一的 RSS 和 k 吗？</h3>
            <p><strong>是的，完全正确！</strong> 这正是 Lasso 算法运行的基础。</p>
            <p>我们可以把 Lasso 看作一个<strong>函数映射机器</strong>：</p>
            <div style="text-align: center; margin: 15px 0;">
                <div style="display: inline-block; border: 2px solid #333; padding: 10px; border-radius: 5px; background: white;">
                    输入 $\lambda$
                </div>
                <span style="font-size: 20px; margin: 0 10px;">➜</span>
                <div style="display: inline-block; background: #34495e; color: white; padding: 10px; border-radius: 5px;">
                    Lasso 最小化求解
                </div>
                <span style="font-size: 20px; margin: 0 10px;">➜</span>
                <div style="display: inline-block; border: 2px solid #333; padding: 10px; border-radius: 5px; background: white;">
                    输出唯一的一组 (RSS, k)
                </div>
            </div>
            <p><strong>工作流程回顾：</strong></p>
            <ol>
                <li>Lasso 算法尝试了成百上千个不同的 $\lambda$。</li>
                <li>对于每一个 $\lambda$，它都通过“最小化”算出了对应的那组 RSS 和 k。</li>
                <li>这样我们就得到了一张长长的列表：<code>[(λ1, RSS1, k1), (λ2, RSS2, k2), ...]</code>。</li>
                <li>最后，AIC 拿着这个列表，算出每一行的 AIC 分数，挑出分数最低的那一行。</li>
            </ol>
        </div>
    </div>

    <div class="step-box">
        <h2>代码对应 (factor_value.py)</h2>
        <div class="code-snippet">
# 1. 准备数据
X_valid = X_train[valid_mask]  # 过去12个月的历史特征
y_valid = y_train[valid_mask]  # 过去12个月的目标收益

# 2. 训练模型 (Lasso + AIC)
lasso = LassoLarsIC(criterion='aic')
lasso.fit(X_valid, y_valid)    # 自动筛选变量

# 3. 预测因子值
pred = lasso.predict(X_current)[0] # 输入当月最新收益，输出预测值
        </div>
    </div>
</div>

</body>
</html>
